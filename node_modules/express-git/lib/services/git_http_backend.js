// Generated by CoffeeScript 1.9.2
(function() {
  var GitUpdateRequest, PassThrough, Promise, ZERO_PKT_LINE, _path, assign, pktline, ref1, ref2, requestStream, spawn, which;

  ref1 = require("../helpers"), requestStream = ref1.requestStream, assign = ref1.assign, spawn = ref1.spawn, pktline = ref1.pktline;

  which = require("shelljs").which;

  _path = require("path");

  Promise = require("bluebird");

  PassThrough = require("stream").PassThrough;

  ref2 = require("../stream"), GitUpdateRequest = ref2.GitUpdateRequest, ZERO_PKT_LINE = ref2.ZERO_PKT_LINE;

  module.exports = function(app, options) {
    var GIT_EXEC, headers;
    if (options == null) {
      options = {};
    }
    GIT_EXEC = (options != null ? options.git_executable : void 0) || which("git");
    headers = function(service, type) {
      if (type == null) {
        type = 'result';
      }
      return {
        'Pragma': 'no-cache',
        'Expires': (new Date('1900')).toISOString(),
        'Cache-Control': 'no-cache, max-age=0, must-revalidate',
        'Content-Type': "application/x-git-" + (service.replace('git-', '')) + "-" + type
      };
    };
    app.post(":repo(.*).git/git-upload-pack", app.authorize("upload-pack"), function(req, res, next) {
      res.set(headers("upload-pack"));
      return req.git.open(req.params.repo).then(function(repo) {
        var args;
        args = ['upload-pack', '--stateless-rpc', repo.path()];
        return spawn(GIT_EXEC, args, {
          stdio: [req, res, res]
        });
      }).then(function() {
        return next();
      })["catch"](next);
    });
    app.post(":repo(.*).git/git-receive-pack", app.authorize("receive-pack"), function(req, res, next) {
      var hook, open, pack, ref3, repo;
      ref3 = req.git, hook = ref3.hook, open = ref3.open;
      res.set(headers("receive-pack"));
      repo = open(req.params.repo);
      pack = new Promise(function(resolve, reject) {
        var git;
        git = new GitUpdateRequest();
        git.on("error", reject);
        git.on("changes", function() {
          git.removeListener("error", reject);
          return resolve(git);
        });
        return requestStream(req).pipe(git);
      });
      return Promise.join(repo, pack, function(repo, pack) {
        var capabilities, changeline, changes;
        capabilities = pack.capabilities, changes = pack.changes;
        changeline = function(arg) {
          var after, before, line, ref;
          before = arg.before, after = arg.after, ref = arg.ref;
          line = [before, after, ref].join(" ");
          if (capabilities) {
            line = line + "\0" + capabilities;
            capabilities = null;
          }
          return pktline(line + "\n");
        };
        return hook('pre-receive', repo, changes).then(function() {
          return changes;
        }).map(function(change) {
          return hook('update', repo, changes).then(function() {
            return change;
          })["catch"](function() {
            return null;
          });
        }).then(function(changes) {
          var c, change, git, i, len, ref4, stderr, stdin, stdout;
          changes = (function() {
            var i, len, results;
            results = [];
            for (i = 0, len = changes.length; i < len; i++) {
              c = changes[i];
              if (c != null) {
                results.push(c);
              }
            }
            return results;
          })();
          if (!(changes.length > 0)) {
            return;
          }
          git = spawn(GIT_EXEC, ["receive-pack", "--stateless-rpc", repo.path()]);
          ref4 = git.process, stdin = ref4.stdin, stdout = ref4.stdout, stderr = ref4.stderr;
          stdout.pipe(res, {
            end: false
          });
          stderr.pipe(res, {
            end: false
          });
          for (i = 0, len = changes.length; i < len; i++) {
            change = changes[i];
            stdin.write(changeline(change));
          }
          stdin.write(ZERO_PKT_LINE);
          pack.pipe(stdin);
          return git;
        }).then(function() {
          return hook('post-receive', repo, changes);
        });
      })["finally"](function() {
        return res.end();
      }).then(function() {
        return next();
      })["catch"](next);
    });
    return app.get("/:repo(.*).git/info/refs", app.authorize("advertise-refs"), function(req, res, next) {
      var service;
      service = req.query.service;
      if (service !== "git-receive-pack" && service !== "git-upload-pack") {
        return next(new BadRequestError);
      }
      service = service.replace('git-', '');
      return req.git.open(req.params.repo).then(function(repo) {
        var args;
        res.set(headers(service, "advertisement"));
        res.write(pktline("# service=git-" + service + "\n"));
        res.write(ZERO_PKT_LINE);
        args = [service, '--stateless-rpc', '--advertise-refs', repo.path()];
        return spawn(GIT_EXEC, args, {
          stdio: ['ignore', res, 'pipe']
        });
      }).then(function() {
        return next();
      })["catch"](next);
    });
  };

}).call(this);

//# sourceMappingURL=git_http_backend.js.map
