// Generated by CoffeeScript 1.9.3
(function() {
  var Changes, SplitLines, Transform, path,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Transform = require("stream").Transform;

  path = require("path");

  SplitLines = (function(superClass) {
    var EMPTY, NEWLINE;

    extend(SplitLines, superClass);

    EMPTY = new Buffer([]);

    NEWLINE = 10;

    function SplitLines() {
      SplitLines.__super__.constructor.apply(this, arguments);
      this.buffer = EMPTY;
    }

    SplitLines.prototype._transform = function(chunk, encoding, callback) {
      var buffer, i, j, len, n, offset;
      buffer = Buffer.concat([this.buffer, chunk]);
      offset = 0;
      for (i = j = 0, len = buffer.length; j < len; i = ++j) {
        n = buffer[i];
        if (!(n === NEWLINE)) {
          continue;
        }
        this.push(buffer.slice(offset, i++));
        offset = i;
      }
      this.buffer = offset < i ? buffer.slice(offset) : EMPTY;
      return callback();
    };

    SplitLines.prototype._flush = function(callback) {
      if (this.buffer.length > 0) {
        this.push(this.buffer);
      }
      return callback();
    };

    return SplitLines;

  })(Transform);

  Changes = (function(superClass) {
    extend(Changes, superClass);

    function Changes(options) {
      if (options == null) {
        options = {};
      }
      options.readableObjectMode = true;
      Changes.__super__.constructor.call(this, options);
    }

    Changes.prototype._transform = function(chunk, encoding, callback) {
      var after, before, ref, ref1;
      ref1 = ("" + chunk).split(/\s+/), before = ref1[0], after = ref1[1], ref = ref1[2];
      this.push({
        before: before,
        after: after,
        ref: ref
      });
      return callback();
    };

    return Changes;

  })(Transform);

  module.exports = function(hook_name) {
    var changes, conn, createConnection, hookdata, id, options, socket;
    socket = process.env.GIT_HOOK_SOCKET;
    id = process.env.GIT_HOOK_ID;
    if (!(id && socket)) {
      process.exit();
    }
    createConnection = require("net").createConnection;
    options = {};
    socket = parseInt(socket) || path.resolve("" + socket);
    if (typeof socket === "number") {
      options.port = socket;
    } else {
      options.path = socket;
    }
    conn = createConnection(options, function() {
      return conn.on("data", function(data) {
        return process.exit(data.readUInt8());
      });
    });
    hookdata = {
      name: hook_name,
      id: id,
      changes: []
    };
    changes = process.stdin.pipe(new SplitLines()).pipe(new Changes());
    changes.on("data", function(c) {
      return hookdata.changes.push(c);
    });
    return changes.on("end", function() {
      conn.write(JSON.stringify(hookdata));
      return conn.end();
    });
  };

}).call(this);

//# sourceMappingURL=hook.js.map
